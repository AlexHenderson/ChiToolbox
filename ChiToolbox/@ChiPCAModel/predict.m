function prediction = predict(varargin)

% predict  Predicts the class labels of a previously unseen data set.
%
% Syntax
%   prediction = predict(unseen);
%   prediction = predict(unseen, pcs);
%
% Description
%   prediction = predict(unseen) predicts class labels, generated by this
%   ChiPCAModel, for each spectrum in unseen. unseen is a ChiSpectrum, or
%   ChiSpectralCollection, and prediction is a ChiPCAPrediction object.
%   By default the number of principal components that are required to
%   explain over 95% of the variance in the model, will be used in the
%   prediction.
%   If unseen has a classmembership, then prediction will include a
%   property indicating whether the spectra were correctly classified.
% 
%   prediction = predict(unseen,pcs) will use up to pcs principal
%   components to perform the prediction.
% 
% Copyright (c) 2020, Alex Henderson.
% Licenced under the GNU General Public License (GPL) version 3.
%
% See also 
%   ChiPCAPrediction ChiSpectralCollection.

% Contact email: alex.henderson@manchester.ac.uk
% Licenced under the GNU General Public License (GPL) version 3
% http://www.gnu.org/copyleft/gpl.html
% Other licensing options are available, please contact Alex for details
% If you use this file in your work, please acknowledge the author(s) in
% your publications. 

% The latest version of this file is available on Bitbucket
% https://bitbucket.org/AlexHenderson/chitoolbox


%% Start timer
predictiontimer = tic();

%% Get this object
this = varargin{1};

%% Identify test data
argposition = find(cellfun(@(x) isa(x,'ChiSpectralCollection') , varargin));
if argposition
    testset = varargin{argposition}.clone;
    varargin(argposition) = [];
else
    argposition = find(cellfun(@(x) isa(x,'ChiSpectrum') , varargin));
    if argposition
        testset = varargin{argposition}.clone;
        varargin(argposition) = [];
    else
        err = MException(['CHI:',mfilename,':InputError'], ...
            'Can only predict ChiSpectra, or ChiSpectralCollections.');
        throw(err);
    end
end

%% Identify number of PCs
pcs = [];
argposition = find(cellfun(@(x) isnumeric(x) , varargin));
if argposition
    pcs = varargin{argposition};
    varargin(argposition) = []; %#ok<NASGU>
end

%% Check we have class membership?
if (isempty(this.classmembership) || isempty(testset.classmembership))
    utilities.warningnobacktrace('These data have no class membership. Only projections will be calculated.');
end

%% Subtract the TRAINING mean from the TEST data
testset.data = testset.data - this.trainingmean.data;

%% Project the test data into the model
% Here we rotate the test data matrix by the same amount that the training
% data was rotated during the original PCA
projectedscores = testset.data * this.loadings;

%% Determine how many PCs make up 95% of the explained variance
if isempty(pcs)
    % Calculate the number of pcs that explain 95% of the variance
    cumpcexplained = cumsum(this.explained);
    pcs = find((cumpcexplained > 95), 1, 'first');
end

%% Make space for results
distances = [];
predictedclass = {};
trueclass = {};
correctlyclassified = [];

%% Only if we have class membership can we determine predicted classes
if ~isempty(this.classmembership)

    % Make space for the results
    distances = zeros(testset.numspectra, this.classmembership.numclasses);

    % Measure the distance of each projected test data point to each class
    for c = 1:this.classmembership.numclasses
        classscores = this.scores((this.classmembership.labelids == c),:);
        distances(:,c) = mahal(projectedscores(:,1:pcs),classscores(:,1:pcs));
    end

    % Determine the predicted class
    [mindist,predictedclassid] = min(distances, [], 2); %#ok<ASGLU>
    predictedclass = this.classmembership.uniquelabels(predictedclassid);
    
    % If we already knew the true labels, we can also calculate the prediction accuracy
    if ~isempty(testset.classmembership)
        trueclass = testset.classmembership.labels;
        correctlyclassified = strcmpi(predictedclass,trueclass);
    end
end 

%% Stop timer
[predictiontime,predictionsec] = tock(predictiontimer); %#ok<ASGLU>

%% Generate results
prediction = ChiPCAPrediction(...
                this.clone(), ...
                projectedscores, ...
                pcs, ...
                predictionsec, ...
                distances, ...
                predictedclass, ...
                trueclass, ...
                correctlyclassified ...
            );

prediction.history.add('PCA prediction of unseen data');

end
