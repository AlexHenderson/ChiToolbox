function prediction = predict(this,unseen,varargin)

% predict  Predicts the class labels of a previously unseen data set.
%
% Syntax
%   prediction = predict(unseen);
%   prediction = predict(unseen, 'parallel');
%
% Description
%   prediction = predict(unseen) predicts class labels, generated by this
%   ChiMLModel, for each spectrum in unseen. unseen is a
%   ChiSpectralCollection and prediction is a ChiMLPrediction object. 
%   If unseen has a classmembership, then prediction will include a
%   property indicating whether the spectra were correctly classified.
% 
%   prediction = predict(unseen,'parallel') attempts to access a parallel
%   pool in order to speed up the prediction. 
% 
% Notes
%   This function requires the Statistics and Machine Learning Toolbox. 
%   The Parallel Computing Toolbox is required for parallel computing. 
%   If the number spectra in unseen is > 10000, and a parallel pool is
%   available, parallel processing will be activated to speed up
%   processing.
% 
% Copyright (c) 2018-2019, Alex Henderson.
% Licenced under the GNU General Public License (GPL) version 3.
%
% See also 
%   ChiSpectralCollection ChiMLPrediction.

% Contact email: alex.henderson@manchester.ac.uk
% Licenced under the GNU General Public License (GPL) version 3
% http://www.gnu.org/copyleft/gpl.html
% Other licensing options are available, please contact Alex for details
% If you use this file in your work, please acknowledge the author(s) in
% your publications. 

% The latest version of this file is available at:
% https://github.com/AlexHenderson/ChiToolbox


%% Do we have the machine learning toolbox
if ~exist('fitcensemble','file')
    err = MException(['CHI:',mfilename,':InputError'], ...
        'The Statistics and Machine Learning Toolbox is required for this function.');
    throw(err);
end

%% Is parallel processing an option?
parallelavailable = exist('parpool','file');

%% Would user like to use a parallel pool?
useparallel = false;
argposition = find(cellfun(@(x) strcmpi(x, 'parallel') , varargin));
if argposition
    if ~parallelavailable
        utilities.warningnobacktrace('The Parallel Computing Toolbox is required to use parallel processing.');
        useparallel = false;
    else
        useparallel = true;
    end
    varargin(argposition) = []; %#ok<NASGU>
end

%% Determine whether to automatically use the parallel pool
% Need to balance the benefits of using the parallel pool with the time
% taken to start it up. 
if (parallelavailable && ~useparallel)
    % User did not specify use of the pool
    if (unseen.numspectra > 10000)
        % Data seems quite large, so turn on the parallel processing
        useparallel = true;
    else 
        useparallel = false;
    end
end

%% Start timer
predictiontimer = tic();

%% Predict
if (parallelavailable && useparallel)
    % We need to break up the data into chunks and allocate these to
    % separate cores. The remainder will be processed after the parallel
    % loop. 
    % We can't write the parallel processed data directly into a variable,
    % so create a cell array to hold the results from each core, and
    % rebuild the outcome later. 
    numcores = feature('numcores');
    looppred = cell(numcores,1);
    loopscores = cell(numcores,1);
    loopstdevs = cell(numcores,1);
    loopdata = cell(numcores,1);
    m = this.model;

    % Break the data into bitesize chunks. 
    numperloop = floor(unseen.numspectra / numcores);
    start = 1;
    for i = 1:numcores
        stop = start + numperloop - 1;
        loopdata{i,1} = unseen.data(start:stop,:);
        start = stop + 1;
    end
    leftoverstart = start;

    % Initiate parallel processing
    parfor i = 1:numcores
        if isa(m,'CompactTreeBagger')
            % Save the stdevs and convert the cell array of numeric strings
            % to actual numbers. DO NOT USE str2double. It's broken.
            [looppred{i},loopscores{i},loopstdevs{i}] = predict(m,loopdata{i});
            looppred{i} = str2num(cell2mat(looppred{i})); %#ok<ST2NM>
        else	% fitcensemble
            [looppred{i},loopscores{i}] = predict(m,loopdata{i});
        end
    end
    
    % Collate the outcomes of each parallel thread into individual variables 
    pred = zeros(unseen.numspectra,1);
    scores = zeros(unseen.numspectra,this.classmembership.numclasses);
    stdevs = zeros(size(scores));
    start = 1;
    for i = 1:numcores
        stop = start + numperloop - 1;
        pred(start:stop) = looppred{i};
        scores(start:stop,:) = loopscores{i};
        if isa(m,'CompactTreeBagger')
            stdevs(start:stop,:) = loopstdevs{i};
        end
        start = stop + 1;
    end
    
    % Now predict the remainder, if there are any
    if (leftoverstart <= unseen.numspectra)
        if isa(m,'CompactTreeBagger')
            [pred(leftoverstart:end),scores(leftoverstart:end,:),stdevs(leftoverstart:end,:)] = predict(this.model,unseen.data(leftoverstart:end,:));
        else
            [pred(leftoverstart:end),scores(leftoverstart:end,:)] = predict(this.model,unseen.data(leftoverstart:end,:));
        end
    end
    
    if ~isa(m,'CompactTreeBagger')
        % Create dummy stdevs for fitcensemble which doesn't calculate
        % them. 
        stdevs = zeros(size(scores));
    end
    
else
    % No pool required
    if isa(this.model,'CompactTreeBagger')
        [pred,scores,stdevs] = predict(this.model,unseen.data);
        pred = str2num(cell2mat(pred)); %#ok<ST2NM>
    else	% fitcensemble
        [pred,scores] = predict(this.model,unseen.data);
        stdevs = zeros(size(scores));
    end
end

%% Did we 'know' our 'unknowns'?
if ~isempty(unseen.classmembership)
    % Yes, our 'unknown' data already had class memberships. 
    % Let's see how many we got right. 
    correctlyclassified = (unseen.classmembership.labelids == pred);
else
    correctlyclassified = [];
end 

%% Stop timer
[predictiontime,predictionsec] = tock(predictiontimer);

%% Generate results
prediction = ChiMLPrediction(...
                pred, ...
                scores, ...
                stdevs, ...
                this.classmembership.clone(), ...
                predictiontime, ...
                predictionsec, ...
                correctlyclassified ...
            );

end
