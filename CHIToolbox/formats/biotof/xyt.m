function [imagedata, mass, totalionimage, filename] = xyt(filename, lowmass, highmass)

%
% Reads the Biotof xyt image file format (Windows or OS/2 versions)
% Version 5 (May 2017)
%
% syntax: [imagedata, mass, totalionimage] = xyt(filename, lowmass, highmass);
% or
% syntax: [imagedata, mass, totalionimage] = xyt();
%
% Takes a file name and optional lower and upper mass limits. If the mass
% limits are not set, they default to 1 and 1000 amu. 
% 
% The second version prompts for a file name and uses the default mass
% limits. 
%
% Returns the following:
%   imagedata
%       A 3D matrix of mass binned spectra where the start mass is 
%       'lowmass' and the end mass is 'highmass' 
%       The mass bins are generated by summing the channels that fall
%       within -0.5 and +0.5 of the nominal mass (the same as BioLines). 
%       These spectra are in rows.
%   mass
%       A row vector of the nominal masses corresponding to the mass range
%       selected. 
%   totalionimage
%       A 2D matrix containing the sum of the intensity at each pixel.
%   filename
%       The location of the file opened.
%
% Changes from version 4 (April 2009)
%   Outputs the filename
% Changes from version 3
%   Now reads OS/2 images. 
%   Fixed the TDC and DA500 channel sizes to 1 ns and 2 ns respectively.
%
% Changes from version 2.1
%   Now reads data acquired using the DA500 transient digitiser.
%   Added the totalionimage output option.
%
% Changes from Version 2.0
%   The image data has been flipped in the vertical axis to match the
%   Biotof software's output
%
% Changes from Version 1.0
%   1) Version 1 read the whole file in before processing and was limited
%   by space in memory. This version reads a pixel at a time and so doesn't
%   have that restriction. 
%   2) We don't handle mass values below zero. 
%   3) There are default low and high mass values which can be set by the
%   user. 
%   4) Because the user can set the mass range, we only output the x values
%   that relate to this range. 
%
% Copyright (c) Alex Henderson, 2008-2017
%

% These are for debugging purposes
%imagedata = [];
%filename = '060504-jsf-dpii011.xyt';
%filename = '060918-mjb-007.xyt';
%lowmass = 1;
%highmass = 1000;

% warning('Double check the mass scale is right, the file format may have changed');

if (exist('filename', 'var') == 0)
    [filename] = getfilename(); % this function is below
    numberofargs = 1;
else
    numberofargs = nargin;
end
    

% Need to keep this default argument management synchronised with sum_xyt.m
switch (numberofargs)
    case 1  % filename only
        lowmass = 1;
        highmass = 1000;
    case 2  % filename and a value - assume high mass
        highmass = lowmass; % single argument so read as lowmass
        lowmass = 1;
    case 3
        % don't do anything since we have filename, low and high masses
    otherwise
        error('Please supply either low and high mass range limits or just the high mass.');
end

if (lowmass > highmass)
    temp = lowmass;
    lowmass = highmass;
    highmass = temp;
end    

if (lowmass < 0)
    error('Sorry this function cannot deal with mass values below zero.');
end

[fid, message] = fopen(filename, 'r', 'l');
if(fid == -1) 
    error(message); 
end;

status = fseek(fid, 0, 'bof');
if(status == -1), message = ferror(fid, 'clear'); error(message); end;
detector_flag = fread(fid, 1, '*int32');

if ((detector_flag == 1408) || (detector_flag == 1034))
    % Windows file
    status = fseek(fid, 3216, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    mass_slope = fread(fid, 1, '*float64');

    status = fseek(fid, 3224, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    mass_intercept = fread(fid, 1, '*float64');

    status = fseek(fid, 3968, 'bof');
    %status = fseek(fid, (3936+5), 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    da500_res = fread(fid, 1, '*double');

    status = fseek(fid, 3976, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    kore_res = fread(fid, 1, '*double');

    status = fseek(fid, 244, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    szdescription1 = fread(fid, 256, '*char');

    status = fseek(fid, 500, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    szdescription2 = fread(fid, 1024, '*char');

    status = fseek(fid, 16, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    flagionsign = fread(fid, 1, '*int32');

    status = fseek(fid, 128, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    image_width = fread(fid, 1, '*int32');
    
    data_offset = 4656;
    
else
    % OS/2 file
    offset = 56;
    status = fseek(fid, offset, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;

    mass_slope = fread(fid, 1, '*float32');
    mass_intercept = fread(fid, 1, '*float32');
    image_size = fread(fid, 1, '*int32');
    image_width = 4096/image_size;

    offset = 204;
    status = fseek(fid, offset, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    kore_res = fread(fid, 1, '*int32');
    da500_res = fread(fid, 1, '*int32');

    offset = 216;
    status = fseek(fid, offset, 'bof');
    if(status == -1), message = ferror(fid, 'clear'); error(message); end;
    detector_flag = fread(fid, 1, '*int32');

    data_offset = 1600;
end


% jump to start of data
status = fseek(fid, data_offset, 'bof');
if(status == -1), message = ferror(fid, 'clear'); error(message); end;

rows = image_width;  
cols = rows;    % currently all our images are square
% space for output
imagedata = zeros(rows, cols, (highmass - lowmass + 1), 'int32');    % 3D array

%   Need to hard code the TimeResolution to 1 ns
%   Can't work out how it's set or where for that matter
%   1 ns is correct for the current TDC, 2 ns required for TD
%   DetectorResolution = 1; 
% Fixed now - June 2008    
% unfixed again since it doesn't appear to work! April 2009

switch detector_flag
   case 1408
      DetectorResolution = kore_res;
      DetectorResolution = 1; % this is right no matter what's in the file
      detector = 'tdc';
   case 1034
      DetectorResolution = da500_res;
      DetectorResolution = 2; % this is right no matter what's in the file
      detector = 'td';
   otherwise
      error('Unknown detector type - problems reading file')
end

 Constant1 = DetectorResolution * (sqrt(mass_slope)) / 1000.0;
% Constant1 = sqrt(mass_slope) / 1000.0;
 Constant2 = mass_intercept * sqrt(mass_slope);

 % work out the limits that we need to output
 % this makes the loop below much faster
 
 low_mass_channel = ((sqrt(lowmass) - Constant2)/Constant1) + 1;
 high_mass_channel = ((sqrt(highmass) - Constant2)/Constant1) + 1;

 % make sure we count the channel if it's on the border
 low_mass_channel_limit = low_mass_channel - 1; 
 high_mass_channel_limit = high_mass_channel + 1;
 
 % handle the data
 % reading the file as we go to conserve memory

 totalionimage = zeros(rows, cols);
 
% put in a huge switch here to save doing many strcmps
 if(strcmp(detector, 'tdc'))
 for row = rows:-1:1    % reverse the order in which we read the rows to match the biotof software
% for row = 1:rows
    for col = 1:cols
        events = fread(fid, 1, 'int32');        % number of events in this pixel
        filedata = fread(fid, events, 'int32'); % actual time channels of events in this pixel

        totalionimage(row, col) = events;
        
        for event_counter = 1:events
            event = filedata(event_counter);       % time channel of event
            if (event > low_mass_channel_limit) && (event < high_mass_channel_limit)
                tempmass = (Constant1 * (double(event)-1)) + Constant2;
                event_mass = tempmass * tempmass;
                event_nominal_mass = round(event_mass); % rounds to the nearest integer
                imagedata(row,col,(event_nominal_mass - lowmass + 1)) = imagedata(row,col,(event_nominal_mass - lowmass + 1)) + 1;
            end
        end
    end
 end

 else
     
  for row = rows:-1:1    % reverse the order in which we read the rows to match the biotof software
% for row = 1:rows
    for col = 1:cols
        events = fread(fid, 1, 'int32');        % number of events in this pixel
        filedata = fread(fid, events, 'int32'); % actual time channels of events in this pixel

        intensitysum = fread(fid, 1, 'int32');        % number of events in this pixel
        intensities = fread(fid, events, 'int32'); % actual time channels of events in this pixel

        totalionimage(row, col) = intensitysum;

        
        for event_counter = 1:events
            event = filedata(event_counter);       % time channel of event
            if (event > low_mass_channel_limit) && (event < high_mass_channel_limit)
                tempmass = (Constant1 * (double(event)-1)) + Constant2;
                event_mass = tempmass * tempmass;
                event_nominal_mass = round(event_mass); % rounds to the nearest integer
                imagedata(row,col,(event_nominal_mass - lowmass + 1)) = imagedata(row,col,(event_nominal_mass - lowmass + 1)) + intensities(event_counter);
            end
        end
    end
  end

 end
 
 
 mass = lowmass:highmass;
 
fclose(fid);

% don't need the data as doubles until sent to MATLAB workspace
imagedata = double(imagedata);

end 
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function [filename] = getfilename()

%
%   Usage: [filename] = getfilename();
%
%   Collects a filename from the user.
%   'filename' is a char array
%
%   (c) Apr 2008, Alex Henderson
%

filetypes = {   '*.xyt',  'Biotof XYT Image Files (*.xyt)'; ...
                '*.*',    'All Files (*.*)'};

[filename, pathname] = uigetfile(filetypes, 'Select file...', 'MultiSelect', 'off');
filename = char([pathname filename]);
end
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
